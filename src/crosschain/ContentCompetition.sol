// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {IFeed, Post} from "@lens-protocol/lens-v3/contracts/core/interfaces/IFeed.sol";
import {LensCrossChain, IRouterClient, Client} from "./LensCrossChain.sol";
import {IContentCompetition} from "../interfaces/IContentCompetition.sol";

/// @title ContentCompetition
/// @author @contractlevel
/// @notice This contract can be used to create competitions for Lens posts.
/// Competition creators must provide a competition theme, prize pool, submission deadline and voting deadline.
/// Users can then submit Lens posts to competitions during the submission period.
/// Users can vote on a submitted post in a competititon during the voting period.
/// The author of the Lens Feed post with the most votes wins the prize pool.
contract ContentCompetition is IContentCompetition, LensCrossChain {
    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/
    error ContentCompetition__PrizePoolRequired();
    error ContentCompetition__InvalidSubmissionDeadline();
    error ContentCompetition__InvalidVotingDeadline();
    error ContentCompetition__InvalidTheme();
    error ContentCompetition__SubmissionsClosed();
    error ContentCompetition__TransferFailed();
    error ContentCompetition__NoZeroValue();
    error ContentCompetition__WithdrawalFailed();
    error ContentCompetition__PostAlreadySubmitted(uint256 competitionId, uint256 postId);
    error ContentCompetition__AlreadyVoted();
    error ContentCompetition__InvalidPost();
    error ContentCompetition__VotingClosed();
    error Competition__VotingNotStarted();

    /*//////////////////////////////////////////////////////////////
                               VARIABLES
    //////////////////////////////////////////////////////////////*/
    struct Competition {
        address creator; // 20-byte pointer // Used to return prizePool if no winner
        bool prizeDistributed; // 1 byte // Ensures prize is distributed only once
        string theme; // 32-byte pointer // Theme or topic of the competition
        uint256 submissionDeadline; // 32 bytes // When submissions end
        uint256 votingDeadline; // 32 bytes // When voting ends
        uint256 prizePool; // 32 bytes // Native token prize pool
        uint256 winningPostId; // 32 bytes // Post ID for the winner!
        uint256[] submissions; // 32-byte pointer // List of submitted postIds for iteration
        mapping(uint256 postId => bool submitted) submitted; // Tracks what has been submitted
        mapping(uint256 postId => uint256 votes) votes; // Votes per submission
        mapping(address => bool) hasVoted; // Tracks who has voted
    }

    /// @dev divide competition msg.value/prizePool by this to get protocolFee
    uint256 internal constant FEE_DENOMINATOR = 100_000;

    /// @dev Lens Feed
    IFeed internal immutable i_feed;

    /// @dev fees generated by the protocol, withdrawable by contract owner
    // invariant: address(this).balance >= protocolFees + totalActivePrizePools
    uint256 internal s_protocolFees;
    /// @dev number of competitions, used for competitionIds (identifiers unique to each competition)
    uint256 internal s_competitionCount;
    /// @dev track competition details by competitionId
    mapping(uint256 competitionId => Competition competition) internal s_competitions;

    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/
    event CompetitionCreated(
        bytes32 indexed ccipMessageId,
        uint256 indexed competitionId,
        uint256 indexed prizePool,
        uint256 submissionDeadline,
        uint256 votingDeadline,
        string theme
    );
    event PrizePoolDistributed(
        bytes32 indexed ccipMessageId,
        address indexed winner,
        uint256 indexed competitionId,
        uint256 winningPostId,
        uint256 prizePool
    );
    event ProtocolFeesWithdrawn(uint256 indexed withdrawnFees);
    event PostSubmitted(uint256 indexed competitionId, uint256 indexed postId);
    event VoteCast(uint256 indexed competitionId, uint256 indexed postId, address indexed voter);

    /*//////////////////////////////////////////////////////////////
                               MODIFIERS
    //////////////////////////////////////////////////////////////*/
    modifier revertIfZero(uint256 input) {
        if (input == 0) revert ContentCompetition__NoZeroValue();
        _;
    }

    /*//////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/
    constructor(address feed, address ccipRouter, uint256 ccipGasLimit) LensCrossChain(ccipRouter, ccipGasLimit) {
        i_feed = IFeed(feed);
        s_competitionCount = 1;
    }

    /*//////////////////////////////////////////////////////////////
                                EXTERNAL
    //////////////////////////////////////////////////////////////*/
    /// @param theme of the competition
    /// @param submissionDeadline posts can be submitted to the competition until this deadline
    /// @param votingDeadline voting takes place between the submission deadline and this deadline
    /// @return ccipMessageId unique identifier for CCIP message
    /// @return competitionId unique identifier for competition
    function createCompetition(string memory theme, uint256 submissionDeadline, uint256 votingDeadline)
        external
        payable
        returns (bytes32 ccipMessageId, uint256 competitionId)
    {
        // @review - what happens if someone sends a very small amount like 1 wei?
        // should we set a minimum prize pool to cover protocolFee?
        if (msg.value == 0) revert ContentCompetition__PrizePoolRequired();
        if (submissionDeadline <= block.timestamp) revert ContentCompetition__InvalidSubmissionDeadline();
        if (votingDeadline <= submissionDeadline) revert ContentCompetition__InvalidVotingDeadline();
        if (bytes(theme).length == 0) revert ContentCompetition__InvalidTheme();

        /// @dev get competitionId and update competitionCount storage
        competitionId = s_competitionCount;
        s_competitionCount = competitionId + 1;

        /// @dev separate protocolFee and prizePool, update storage
        uint256 protocolFee = _calculateProtocolFee(msg.value);
        uint256 prizePool;
        if (protocolFee != 0) {
            prizePool = msg.value - protocolFee;
            s_protocolFees += protocolFee;
        } else {
            prizePool = msg.value;
        }

        /// @dev update storage with competition details
        Competition storage s_comp = s_competitions[competitionId];
        s_comp.theme = theme;
        s_comp.submissionDeadline = submissionDeadline;
        s_comp.votingDeadline = votingDeadline;
        s_comp.prizePool = prizePool;

        /// @dev send CCIP Message with competitionId and votingDeadline to a chain with automation
        ccipMessageId = _ccipSend(competitionId, votingDeadline);

        emit CompetitionCreated(ccipMessageId, competitionId, prizePool, submissionDeadline, votingDeadline, theme);
    }

    /// @notice Allows a user to submit a post to a competition
    /// @param competitionId The ID of the competition to submit to
    /// @param postId The ID of the post being submitted
    function submitPost(uint256 competitionId, uint256 postId)
        external
        revertIfZero(competitionId)
        revertIfZero(postId)
    {
        Competition storage s_comp = s_competitions[competitionId];

        if (block.timestamp > s_comp.submissionDeadline) revert ContentCompetition__SubmissionsClosed();
        if (s_comp.submitted[postId]) revert ContentCompetition__PostAlreadySubmitted(competitionId, postId);
        if (!i_feed.postExists(postId)) revert ContentCompetition__InvalidPost();

        // Mark the post as submitted and add it to the submissions array
        s_comp.submitted[postId] = true;
        s_comp.submissions.push(postId);

        // Emit an event to log the submission
        emit PostSubmitted(competitionId, postId);
    }

    /// @notice Allows a user to vote for a post in a competition
    /// @param competitionId The ID of the competition
    /// @param postId The ID of the post to vote for
    function vote(uint256 competitionId, uint256 postId) external revertIfZero(competitionId) revertIfZero(postId) {
        Competition storage s_comp = s_competitions[competitionId];

        if (block.timestamp <= s_comp.submissionDeadline) revert Competition__VotingNotStarted();
        if (block.timestamp > s_comp.votingDeadline) revert ContentCompetition__VotingClosed();
        if (s_comp.hasVoted[msg.sender]) revert ContentCompetition__AlreadyVoted();
        if (!s_comp.submitted[postId]) revert ContentCompetition__InvalidPost();

        // Record the vote
        s_comp.votes[postId] += 1;
        s_comp.hasVoted[msg.sender] = true;

        // Emit an event to log the vote
        emit VoteCast(competitionId, postId, msg.sender);
    }

    function withdrawProtocolFees() external onlyOwner {
        uint256 fees = s_protocolFees;
        s_protocolFees = 0;
        (bool success,) = payable(msg.sender).call{value: fees}("");
        if (!success) revert ContentCompetition__WithdrawalFailed();
        emit ProtocolFeesWithdrawn(fees);
    }

    /*//////////////////////////////////////////////////////////////
                            INTERNAL
    //////////////////////////////////////////////////////////////*/
    /// @notice send CCIP Message with competitionId and votingDeadline to a chain with automation
    function _ccipSend(uint256 competitionId, uint256 votingDeadline) internal returns (bytes32 ccipMessageId) {
        /// @dev build message
        bytes memory data = abi.encode(competitionId, votingDeadline);
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(s_allowedPeer, data);
        /// @dev handle fees
        uint64 dstChainSelector = s_allowedChain;
        uint256 fees = _getCCIPFees(dstChainSelector, evm2AnyMessage);
        /// @dev send message
        ccipMessageId = IRouterClient(i_ccipRouter).ccipSend{value: fees}(dstChainSelector, evm2AnyMessage);
    }

    /// @param message Any2EVMMessage.
    function _ccipReceive(Client.Any2EVMMessage memory message)
        internal
        override
        onlyAllowed(message.sourceChainSelector, abi.decode(message.sender, (address)))
    {
        /// @dev decode competitionId
        uint256 competitionId = abi.decode(message.data, (uint256));

        (address winner, uint256 winningPostId, uint256 prizePool) = _distributePrizePool(competitionId);
        emit PrizePoolDistributed(message.messageId, winner, competitionId, winningPostId, prizePool);
    }

    function _distributePrizePool(uint256 competitionId)
        internal
        returns (address winner, uint256 winningPostId, uint256 prizePool)
    {
        /// @dev update storage with the competitionId and send prize pool to winning author
        Competition storage s_comp = s_competitions[competitionId];

        /// @dev find submission with most votes
        uint256 maxVotes;
        uint256[] memory submissions = s_comp.submissions;
        uint256 submissionCount = submissions.length;

        if (submissionCount == 0) {
            // No submissions: prize goes to creator
            winner = s_comp.creator;
            winningPostId = 0;
        } else {
            // Find the post with the most votes
            for (uint256 i = 0; i < submissionCount; ++i) {
                uint256 postId = submissions[i];
                uint256 voteCount = s_comp.votes[postId];
                /// @dev if there is a tie, the post that got the most votes first is the winner
                // @review - The "first to reach" rule is approximated by submission order, not vote timestamp.
                if (voteCount > maxVotes) {
                    maxVotes = voteCount;
                    winningPostId = postId;
                }
            }

            if (maxVotes == 0) {
                // Submissions exist but no votes: prize goes to creator
                winner = s_comp.creator;
                winningPostId = 0;
            } else {
                // Submissions with votes: prize goes to the author of the winning post
                winner = i_feed.getPostAuthor(winningPostId);
                if (winner == address(0)) winner = s_comp.creator;
            }
        }

        /// @dev if no votes were cast, prizePool is returned to creator
        if (maxVotes == 0 && submissionCount > 0) winningPostId = 0;
        winner = i_feed.getPostAuthor(winningPostId);
        if (winner == address(0)) winner = s_comp.creator;

        /// @dev update state
        s_comp.prizeDistributed = true;
        s_comp.winningPostId = winningPostId;

        /// @dev send prize
        prizePool = s_comp.prizePool;

        (bool success,) = winner.call{value: prizePool}("");
        if (!success) revert ContentCompetition__TransferFailed();

        return (winner, winningPostId, prizePool);
    }

    function _calculateProtocolFee(uint256 prizePool) internal pure returns (uint256 protocolFee) {
        // @review - could this cause under/overflow issues?
        return prizePool / FEE_DENOMINATOR;
    }

    /// this is for ccip payments
    receive() external payable {}

    /*//////////////////////////////////////////////////////////////
                                 GETTER
    //////////////////////////////////////////////////////////////*/
    function getCalculatedProcolFee(uint256 prizePool) external pure returns (uint256) {
        return _calculateProtocolFee(prizePool);
    }

    function getAllowedChainSelector() external view returns (uint64) {
        return s_allowedChain;
    }

    function getCompetition(uint256 competitionId)
        external
        view
        returns (
            address creator,
            bool prizeDistributed,
            string memory theme,
            uint256 submissionDeadline,
            uint256 votingDeadline,
            uint256 prizePool,
            uint256 winningPostId,
            uint256[] memory submissions
        )
    {
        Competition storage s_comp = s_competitions[competitionId];
        return (
            s_comp.creator,
            s_comp.prizeDistributed,
            s_comp.theme,
            s_comp.submissionDeadline,
            s_comp.votingDeadline,
            s_comp.prizePool,
            s_comp.winningPostId,
            s_comp.submissions
        );
    }

    function getSubmissionDeadline(uint256 competitionId) external view returns (uint256) {
        return s_competitions[competitionId].submissionDeadline;
    }

    function getVotingDeadline(uint256 competitionId) external view returns (uint256) {
        return s_competitions[competitionId].votingDeadline;
    }

    function getVotes(uint256 competitionId, uint256 postId) external view returns (uint256) {
        return s_competitions[competitionId].votes[postId];
    }

    function getWinningAuthor(uint256 competitionId) external view returns (address) {
        return i_feed.getPostAuthor(s_competitions[competitionId].winningPostId);
    }

    function getSubmitted(uint256 competitionId, uint256 postId) external view returns (bool) {
        return s_competitions[competitionId].submitted[postId];
    }

    function getVoted(uint256 competitionId, address voter) external view returns (bool) {
        return s_competitions[competitionId].hasVoted[voter];
    }

    function getPrizeDistributed(uint256 competitionId) external view returns (bool) {
        return s_competitions[competitionId].prizeDistributed;
    }

    function getCompetitionCreator(uint256 competitionId) external view returns (address) {
        return s_competitions[competitionId].creator;
    }
}
