// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {IFeed, Post} from "@lens-protocol/lens-v3/contracts/core/interfaces/IFeed.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ICompetitions} from "./interfaces/ICompetitions.sol";

/// @title Competitions
/// @author @contractlevel
/// @notice This contract can be used to create competitions for Lens posts.
/// Competition creators must provide a competition theme, prize pool, submission deadline and voting deadline.
/// Users can then submit Lens posts to competitions during the submission period.
/// Users can vote on a submitted post in a competititon during the voting period.
/// The author of the Lens Feed post with the most votes wins the prize pool.
contract Competitions is Ownable, ICompetitions {
    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/
    error Competitions__PrizePoolRequired();
    error Competitions__InvalidSubmissionDeadline();
    error Competitions__InvalidVotingDeadline();
    error Competitions__InvalidTheme();
    error Competitions__SubmissionsClosed();
    error Competitions__TransferFailed();
    error Competitions__NoZeroValue();
    error Competitions__WithdrawalFailed();
    error Competitions__PostAlreadySubmitted();
    error Competitions__AlreadyVoted();
    error Competitions__InvalidPost();
    error Competitions__VotingClosed();
    error Competitions__VotingNotStarted();
    error Competitions__VotingNotFinished();
    error Competitions__PrizeAlreadyDistributed();

    /*//////////////////////////////////////////////////////////////
                               VARIABLES
    //////////////////////////////////////////////////////////////*/
    struct Competition {
        address creator; // 20-byte pointer // Used to return prizePool if no winner
        bool prizeDistributed; // 1 byte // Ensures prize is distributed only once
        string theme; // 32-byte pointer // Theme or topic of the competition
        uint256 submissionDeadline; // 32 bytes // When submissions end
        uint256 votingDeadline; // 32 bytes // When voting ends
        uint256 prizePool; // 32 bytes // Native token prize pool
        uint256 winningPostId; // 32 bytes // Post ID for the winner!
        uint256[] submissions; // 32-byte pointer // List of submitted postIds for iteration
        mapping(uint256 postId => bool submitted) submitted; // Tracks what has been submitted
        mapping(uint256 postId => uint256 votes) votes; // Votes per submission
        mapping(address => bool) hasVoted; // Tracks who has voted
    }

    /// @dev divide competition msg.value/prizePool by this to get protocolFee
    uint256 internal constant FEE_DENOMINATOR = 100_000;

    /// @dev Lens Feed
    IFeed internal immutable i_feed;

    /// @dev fees generated by the protocol, withdrawable by contract owner
    // invariant: address(this).balance >= protocolFees + totalActivePrizePools
    uint256 internal s_protocolFees;
    /// @dev number of competitions, used for competitionIds (identifiers unique to each competition)
    uint256 internal s_competitionCount;
    /// @dev track competition details by competitionId
    mapping(uint256 competitionId => Competition competition) internal s_competitions;

    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/
    event CompetitionCreated(
        uint256 indexed competitionId,
        uint256 indexed prizePool,
        uint256 submissionDeadline,
        uint256 votingDeadline,
        string theme
    );
    event PrizePoolDistributed(
        address indexed winner, uint256 indexed competitionId, uint256 indexed winningPostId, uint256 prizePool
    );
    event ProtocolFeesWithdrawn(uint256 indexed withdrawnFees);
    event PostSubmitted(uint256 indexed competitionId, uint256 indexed postId);
    event VoteCast(uint256 indexed competitionId, uint256 indexed postId, address indexed voter);

    /*//////////////////////////////////////////////////////////////
                               MODIFIERS
    //////////////////////////////////////////////////////////////*/
    modifier revertIfZero(uint256 input) {
        if (input == 0) revert Competitions__NoZeroValue();
        _;
    }

    /*//////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/
    constructor(address feed) Ownable(msg.sender) {
        i_feed = IFeed(feed);
        s_competitionCount = 1;
    }

    /*//////////////////////////////////////////////////////////////
                                EXTERNAL
    //////////////////////////////////////////////////////////////*/
    /// @param theme of the competition
    /// @param submissionDeadline posts can be submitted to the competition until this deadline
    /// @param votingDeadline voting takes place between the submission deadline and this deadline
    /// @return competitionId unique identifier for competition
    function createCompetition(string memory theme, uint256 submissionDeadline, uint256 votingDeadline)
        external
        payable
        returns (uint256 competitionId)
    {
        // @review - what happens if someone sends a very small amount like 1 wei?
        // should we set a minimum prize pool to cover protocolFee?
        if (msg.value == 0) revert Competitions__PrizePoolRequired();
        if (submissionDeadline <= block.timestamp) revert Competitions__InvalidSubmissionDeadline();
        if (votingDeadline <= submissionDeadline) revert Competitions__InvalidVotingDeadline();
        if (bytes(theme).length == 0) revert Competitions__InvalidTheme();

        /// @dev get competitionId and update competitionCount storage
        competitionId = s_competitionCount;
        s_competitionCount = competitionId + 1;

        /// @dev separate protocolFee and prizePool, update storage
        uint256 protocolFee = _calculateProtocolFee(msg.value);
        uint256 prizePool;
        if (protocolFee != 0) {
            prizePool = msg.value - protocolFee;
            s_protocolFees += protocolFee;
        } else {
            prizePool = msg.value;
        }

        /// @dev update storage with competition details
        Competition storage s_comp = s_competitions[competitionId];
        s_comp.theme = theme;
        s_comp.submissionDeadline = submissionDeadline;
        s_comp.votingDeadline = votingDeadline;
        s_comp.prizePool = prizePool;
        s_comp.creator = msg.sender;

        emit CompetitionCreated(competitionId, prizePool, submissionDeadline, votingDeadline, theme);
    }

    /// @notice Allows a user to submit a post to a competition
    /// @param competitionId The ID of the competition to submit to
    /// @param postId The ID of the post being submitted
    function submitPost(uint256 competitionId, uint256 postId)
        external
        revertIfZero(competitionId)
        revertIfZero(postId)
    {
        Competition storage s_comp = s_competitions[competitionId];

        if (block.timestamp > s_comp.submissionDeadline) revert Competitions__SubmissionsClosed();
        if (s_comp.submitted[postId]) revert Competitions__PostAlreadySubmitted();
        if (!i_feed.postExists(postId)) revert Competitions__InvalidPost();

        // Mark the post as submitted and add it to the submissions array
        s_comp.submitted[postId] = true;
        s_comp.submissions.push(postId);

        // Emit an event to log the submission
        emit PostSubmitted(competitionId, postId);
    }

    /// @notice Allows a user to vote for a post in a competition
    /// @param competitionId The ID of the competition
    /// @param postId The ID of the post to vote for
    function vote(uint256 competitionId, uint256 postId) external revertIfZero(competitionId) revertIfZero(postId) {
        Competition storage s_comp = s_competitions[competitionId];

        if (block.timestamp <= s_comp.submissionDeadline) revert Competitions__VotingNotStarted();
        if (block.timestamp > s_comp.votingDeadline) revert Competitions__VotingClosed();
        if (s_comp.hasVoted[msg.sender]) revert Competitions__AlreadyVoted();
        if (!s_comp.submitted[postId]) revert Competitions__InvalidPost();

        // Record the vote
        s_comp.votes[postId] += 1;
        s_comp.hasVoted[msg.sender] = true;

        // Emit an event to log the vote
        emit VoteCast(competitionId, postId, msg.sender);
    }

    /// @notice Distributes the prize pool to the winner
    /// @dev Anyone can call this function when the voting deadline has passed
    /// @param competitionId The ID of the competition
    /// @return winner The address of the winner
    /// @return winningPostId The ID of the winning post
    /// @return prizePool The prize pool
    function distributePrizePool(uint256 competitionId)
        external
        revertIfZero(competitionId)
        returns (address winner, uint256 winningPostId, uint256 prizePool)
    {
        /// @dev update storage with the competitionId and send prize pool to winning author
        Competition storage s_comp = s_competitions[competitionId];
        if (block.timestamp <= s_comp.votingDeadline) revert Competitions__VotingNotFinished();
        if (s_comp.prizeDistributed) revert Competitions__PrizeAlreadyDistributed();

        /// @dev find submission with most votes
        uint256 maxVotes;
        uint256[] memory submissions = s_comp.submissions;
        uint256 submissionCount = submissions.length;

        if (submissionCount == 0) {
            // No submissions: prize goes to creator
            winner = s_comp.creator;
            winningPostId = 0;
        } else {
            // Find the post with the most votes
            for (uint256 i = 0; i < submissionCount; ++i) {
                uint256 postId = submissions[i];
                uint256 voteCount = s_comp.votes[postId];
                /// @dev if there is a tie, the post that got the most votes first is the winner
                // @review - The "first to reach" rule is approximated by submission order, not vote timestamp.
                if (voteCount > maxVotes) {
                    maxVotes = voteCount;
                    winningPostId = postId;
                }
            }

            if (maxVotes == 0) {
                // Submissions exist but no votes: prize goes to creator
                winner = s_comp.creator;
                winningPostId = 0;
            } else {
                // Submissions with votes: prize goes to the author of the winning post
                winner = i_feed.getPostAuthor(winningPostId);
                if (winner == address(0)) winner = s_comp.creator;
            }
        }

        /// @dev update state
        s_comp.prizeDistributed = true;
        s_comp.winningPostId = winningPostId;

        /// @dev send prize
        prizePool = s_comp.prizePool;

        (bool success,) = winner.call{value: prizePool}("");
        if (!success) revert Competitions__TransferFailed();

        return (winner, winningPostId, prizePool);
    }

    function withdrawProtocolFees() external onlyOwner {
        uint256 fees = s_protocolFees;
        s_protocolFees = 0;
        (bool success,) = payable(msg.sender).call{value: fees}("");
        if (!success) revert Competitions__WithdrawalFailed();
        emit ProtocolFeesWithdrawn(fees);
    }

    /*//////////////////////////////////////////////////////////////
                            INTERNAL
    //////////////////////////////////////////////////////////////*/
    function _calculateProtocolFee(uint256 prizePool) internal pure returns (uint256 protocolFee) {
        // @review - could this cause under/overflow issues?
        return prizePool / FEE_DENOMINATOR;
    }

    /*//////////////////////////////////////////////////////////////
                                 GETTER
    //////////////////////////////////////////////////////////////*/
    function getProtocolFee(uint256 prizePool) external pure returns (uint256) {
        return _calculateProtocolFee(prizePool);
    }

    function getProtocolFees() external view returns (uint256) {
        return s_protocolFees;
    }

    function getCompetition(uint256 competitionId)
        external
        view
        returns (
            address creator,
            bool prizeDistributed,
            string memory theme,
            uint256 submissionDeadline,
            uint256 votingDeadline,
            uint256 prizePool,
            uint256 winningPostId,
            uint256[] memory submissions
        )
    {
        Competition storage s_comp = s_competitions[competitionId];
        return (
            s_comp.creator,
            s_comp.prizeDistributed,
            s_comp.theme,
            s_comp.submissionDeadline,
            s_comp.votingDeadline,
            s_comp.prizePool,
            s_comp.winningPostId,
            s_comp.submissions
        );
    }

    function getSubmissionDeadline(uint256 competitionId) external view returns (uint256) {
        return s_competitions[competitionId].submissionDeadline;
    }

    function getVotingDeadline(uint256 competitionId) external view returns (uint256) {
        return s_competitions[competitionId].votingDeadline;
    }

    function getVotes(uint256 competitionId, uint256 postId) external view returns (uint256) {
        return s_competitions[competitionId].votes[postId];
    }

    function getWinningAuthor(uint256 competitionId) external view returns (address) {
        return i_feed.getPostAuthor(s_competitions[competitionId].winningPostId);
    }

    function getSubmitted(uint256 competitionId, uint256 postId) external view returns (bool) {
        return s_competitions[competitionId].submitted[postId];
    }

    function getVoted(uint256 competitionId, address voter) external view returns (bool) {
        return s_competitions[competitionId].hasVoted[voter];
    }

    function getPrizeDistributed(uint256 competitionId) external view returns (bool) {
        return s_competitions[competitionId].prizeDistributed;
    }

    function getCreator(uint256 competitionId) external view returns (address) {
        return s_competitions[competitionId].creator;
    }

    function getPrizePool(uint256 competitionId) external view returns (uint256) {
        return s_competitions[competitionId].prizePool;
    }

    function getWinningPostId(uint256 competitionId) external view returns (uint256) {
        return s_competitions[competitionId].winningPostId;
    }

    function getSubmissions(uint256 competitionId) external view returns (uint256[] memory) {
        return s_competitions[competitionId].submissions;
    }

    function getTheme(uint256 competitionId) external view returns (string memory) {
        return s_competitions[competitionId].theme;
    }
}
