// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {IFeed, Post} from "@lens-protocol/lens-v3/contracts/core/interfaces/IFeed.sol";
import {CrossChain, IRouterClient, Client} from "./CrossChain.sol";
import {IContentCompetition} from "./interfaces/IContentCompetition.sol";

/// @title ContentCompetition
/// @author @contractlevel
contract ContentCompetition is IContentCompetition, CrossChain {
    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/
    error ContentCompetition__PrizePoolRequired();
    error ContentCompetition__InvalidSubmissionDeadline();
    error ContentCompetition__InvalidVotingDeadline();
    error ContentCompetition__InvalidTheme();
    error ContentCompetition__SubmissionsClosed();
    error ContentCompetition__TransferFailed();
    error ContentCompetition__NoZeroValue();
    error ContentCompetition__WithdrawalFailed();
    error ContentCompetition__PostAlreadySubmitted(uint256 competitionId, uint256 postId);
    error ContentCompetition_AlreadyVoted();
    error ContentCompetition__InvalidPost();
    error ContentCompetition__VotingClosed();

    /*//////////////////////////////////////////////////////////////
                               VARIABLES
    //////////////////////////////////////////////////////////////*/
    struct Competition {
        address creator; // 20-byte pointer // Used to return prizePool if no winner
        bool prizeDistributed; // 1 byte // Ensures prize is distributed only once
        string theme; // 32-byte pointer // Theme or topic of the competition
        uint256 submissionDeadline; // 32 bytes // When submissions end
        uint256 votingDeadline; // 32 bytes // When voting ends
        uint256 prizePool; // 32 bytes // Native token prize pool
        uint256[] submissions; // 32-byte pointer // List of submitted postIds for iteration
        mapping(uint256 postId => bool submitted) submitted; // Tracks what has been submitted
        mapping(uint256 postId => uint256 votes) votes; // Votes per submission
        mapping(address => bool) hasVoted; // Tracks who has voted
    }

    /// @dev divide competition msg.value/prizePool by this to get protocolFee
    uint256 internal constant FEE_DENOMINATOR = 100_000;

    /// @dev Lens Feed
    IFeed internal immutable i_feed;

    /// @dev fees generated by the protocol, withdrawable by contract owner
    // invariant: address(this).balance >= protocolFees + totalActivePrizePools
    uint256 internal s_protocolFees;
    /// @dev number of competitions, used for competitionIds (identifiers unique to each competition)
    uint256 internal s_competitionCount;
    /// @dev track competition details by competitionId
    mapping(uint256 competitionId => Competition competition) internal s_competitions;

    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/
    event CompetitionCreated(
        bytes32 indexed ccipMessageId,
        uint256 indexed competitionId,
        uint256 indexed prizePool,
        uint256 submissionDeadline,
        uint256 votingDeadline,
        string theme
    );
    event PrizePoolDistributed(
        bytes32 indexed ccipMessageId,
        address indexed winner,
        uint256 indexed competitionId,
        uint256 winningPostId,
        uint256 prizePool
    );
    event ProtocolFeesWithdrawn(uint256 indexed withdrawnFees);
    event PostSubmitted(uint256 indexed competitionId, uint256 indexed postId);
    event VoteCast(uint256 indexed competitionId, uint256 indexed postId, address indexed voter);

    /*//////////////////////////////////////////////////////////////
                               MODIFIERS
    //////////////////////////////////////////////////////////////*/
    modifier revertIfZero(uint256 input) {
        if (input == 0) revert ContentCompetition__NoZeroValue();
        _;
    }

    /*//////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/
    constructor(address feed, address link, address ccipRouter, uint256 ccipGasLimit)
        CrossChain(link, ccipRouter, ccipGasLimit)
    {
        i_feed = IFeed(feed);
        s_competitionCount = 1;
    }

    /*//////////////////////////////////////////////////////////////
                                EXTERNAL
    //////////////////////////////////////////////////////////////*/
    /// @param theme of the competition
    /// @param submissionDeadline posts can be submitted to the competition until this deadline
    /// @param votingDeadline voting takes place between the submission deadline and this deadline
    /// @return ccipMessageId unique identifier for CCIP message
    /// @return competitionId unique identifier for competition
    function createCompetition(string memory theme, uint256 submissionDeadline, uint256 votingDeadline)
        external
        payable
        returns (bytes32 ccipMessageId, uint256 competitionId)
    {
        // @review - what happens if someone sends a very small amount like 1 wei?
        // should we set a minimum prize pool to cover protocolFee?
        if (msg.value == 0) revert ContentCompetition__PrizePoolRequired();
        if (submissionDeadline <= block.timestamp) revert ContentCompetition__InvalidSubmissionDeadline();
        if (votingDeadline <= submissionDeadline) revert ContentCompetition__InvalidVotingDeadline();
        if (bytes(theme).length == 0) revert ContentCompetition__InvalidTheme();

        /// @dev get competitionId and update competitionCount storage
        competitionId = s_competitionCount;
        s_competitionCount = competitionId + 1;

        /// @dev separate protocolFee and prizePool, update storage
        uint256 protocolFee = _calculateProtocolFee(msg.value);
        uint256 prizePool = msg.value - protocolFee;
        if (protocolFee != 0) s_protocolFees += protocolFee;

        /// @dev update storage with competition details
        Competition storage s_comp = s_competitions[competitionId];
        s_comp.theme = theme;
        s_comp.submissionDeadline = submissionDeadline;
        s_comp.votingDeadline = votingDeadline;
        s_comp.prizePool = prizePool;

        /// @dev send CCIP Message with competitionId and votingDeadline to a chain with automation
        ccipMessageId = _ccipSend(competitionId, votingDeadline);

        emit CompetitionCreated(ccipMessageId, competitionId, prizePool, submissionDeadline, votingDeadline, theme);
    }

    /// @notice Allows a user to submit a post to a competition
    /// @param competitionId The ID of the competition to submit to
    /// @param postId The ID of the post being submitted
    function submitPost(uint256 competitionId, uint256 postId)
        external
        revertIfZero(competitionId)
        revertIfZero(postId)
    {
        Competition storage s_comp = s_competitions[competitionId];

        if (block.timestamp > s_comp.submissionDeadline) revert ContentCompetition__SubmissionsClosed();
        if (s_comp.submitted[postId]) revert ContentCompetition__PostAlreadySubmitted(competitionId, postId);

        // Mark the post as submitted and add it to the submissions array
        s_comp.submitted[postId] = true;
        s_comp.submissions.push(postId);

        // Emit an event to log the submission
        emit PostSubmitted(competitionId, postId);
    }

    /// @notice Allows a user to vote for a post in a competition
    /// @param competitionId The ID of the competition
    /// @param postId The ID of the post to vote for
    function vote(uint256 competitionId, uint256 postId) external revertIfZero(competitionId) revertIfZero(postId) {
        Competition storage s_comp = s_competitions[competitionId];

        if (block.timestamp > s_comp.votingDeadline) revert ContentCompetition__VotingClosed();
        if (s_comp.hasVoted[msg.sender]) revert ContentCompetition_AlreadyVoted();
        if (!s_comp.submitted[postId]) revert ContentCompetition__InvalidPost();

        // Record the vote
        s_comp.votes[postId] += 1;
        s_comp.hasVoted[msg.sender] = true;

        // Emit an event to log the vote
        emit VoteCast(competitionId, postId, msg.sender);
    }

    function withdrawProtocolFees() external onlyOwner {
        uint256 fees = s_protocolFees;
        s_protocolFees = 0;
        (bool success,) = payable(msg.sender).call{value: fees}("");
        if (!success) revert ContentCompetition__WithdrawalFailed();
        emit ProtocolFeesWithdrawn(fees);
    }

    /// @notice onlyOwner utility function for withdrawing LINK
    function withdrawLink() external onlyOwner {
        i_link.transfer(msg.sender, i_link.balanceOf(address(this)));
    }

    /*//////////////////////////////////////////////////////////////
                            INTERNAL
    //////////////////////////////////////////////////////////////*/
    /// @notice send CCIP Message with competitionId and votingDeadline to a chain with automation
    function _ccipSend(uint256 competitionId, uint256 votingDeadline) internal returns (bytes32 ccipMessageId) {
        /// @dev build message
        bytes memory data = abi.encode(competitionId, votingDeadline);
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(s_allowedPeer, data);
        /// @dev handle fees
        uint64 dstChainSelector = s_allowedChain;
        uint256 fees = _getCCIPFees(dstChainSelector, evm2AnyMessage);
        i_link.approve(i_ccipRouter, fees);
        /// @dev send message
        ccipMessageId = IRouterClient(i_ccipRouter).ccipSend(dstChainSelector, evm2AnyMessage);
    }

    /// @param message Any2EVMMessage.
    function _ccipReceive(Client.Any2EVMMessage memory message)
        internal
        override
        onlyAllowed(message.sourceChainSelector, abi.decode(message.sender, (address)))
    {
        /// @dev decode competitionId
        uint256 competitionId = abi.decode(message.data, (uint256));

        (address winner, uint256 winningPostId, uint256 prizePool) = _distributePrizePool(competitionId);
        emit PrizePoolDistributed(message.messageId, winner, competitionId, winningPostId, prizePool);
    }

    function _distributePrizePool(uint256 competitionId)
        internal
        returns (address winner, uint256 winningPostId, uint256 prizePool)
    {
        /// @dev update storage with the competitionId and send prize pool to winning author
        Competition storage s_comp = s_competitions[competitionId];

        /// @dev find submission with most votes
        uint256 maxVotes;
        uint256[] memory submissions = s_comp.submissions;
        uint256 submissionCount = submissions.length;

        for (uint256 i = 0; i < submissionCount; ++i) {
            uint256 postId = submissions[i];
            uint256 voteCount = s_comp.votes[postId];
            // @review - what if there is a tie?
            if (voteCount > maxVotes) {
                maxVotes = voteCount;
                winningPostId = postId;
            }
        }

        /// @dev if no votes were cast, prizePool is returned to creator
        if (maxVotes == 0 && submissionCount > 0) winningPostId = 0;
        winner = i_feed.getPostAuthor(winningPostId);
        if (winner == address(0)) winner = s_comp.creator;

        /// @dev update state
        s_comp.prizeDistributed = true;

        /// @dev send prize
        prizePool = s_comp.prizePool;
        (bool success,) = winner.call{value: prizePool}("");
        if (!success) revert ContentCompetition__TransferFailed();

        return (winner, winningPostId, prizePool);
    }

    function _calculateProtocolFee(uint256 prizePool) internal pure returns (uint256 protocolFee) {
        // @review - could this cause under/overflow issues?
        return prizePool / FEE_DENOMINATOR;
    }
}
