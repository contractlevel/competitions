// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {IFeed, Post} from "@lens-protocol/lens-v3/contracts/core/interfaces/IFeed.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {LinkTokenInterface} from "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol";
import {CCIPReceiver} from "@chainlink/contracts/src/v0.8/ccip/applications/CCIPReceiver.sol";
import {IRouterClient, Client} from "@chainlink/contracts/src/v0.8/ccip/interfaces/IRouterClient.sol";
import {IContentCompetition} from "./interfaces/IContentCompetition.sol";

// address author = IFeed().getPostAuthor(postId);

contract ContentCompetition is Ownable, IContentCompetition, CCIPReceiver {
    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/
    error ContentCompetition__PrizePoolRequired();
    error ContentCompetition__InvalidSubmissionDeadline();
    error ContentCompetition__InvalidVotingDeadline();
    error ContentCompetition__InvalidTheme();
    error ContentCompetition__SubmissionsClosed();

    /*//////////////////////////////////////////////////////////////
                               VARIABLES
    //////////////////////////////////////////////////////////////*/
    /// @dev divide competition msg.value/prizePool by this to get protocolFee
    uint256 internal constant FEE_DENOMINATOR = 100_000;

    /// @dev Lens Feed
    IFeed internal immutable i_feed;
    /// @dev Chainlink token
    LinkTokenInterface internal immutable i_link;

    /// @dev
    mapping(uint256 competitionId => Competition competition) internal s_competitions;
    /// @dev number of competitions, used for competitionIds (identifiers unique to each competition)
    uint256 internal s_competitionCount;
    /// @dev fees generated by the protocol, withdrawable by contract owner
    uint256 internal s_protocolFees;

    struct Competition {
        string theme; // 32-byte pointer // Theme or topic of the competition
        uint256 submissionDeadline; // 32 bytes // When submissions end
        uint256 votingDeadline; // 32 bytes // When voting ends
        uint256 prizePool; // 32 bytes // Native token prize pool
        uint256[] submissions; // 32-byte pointer // List of submitted postIds for iteration
        bool prizeDistributed; // 1 byte // Ensures prize is distributed only once
        mapping(uint256 postId => bool submitted) submitted; // Tracks what has been submitted
        mapping(uint256 postId => uint256 votes) votes; // Votes per submission
        mapping(address => bool) hasVoted; // Tracks who has voted
    }

    /*//////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/
    constructor(address feed, address link, address ccipRouter) Ownable(msg.sender) CCIPReceiver(ccipRouter) {
        i_feed = IFeed(feed);
        i_link = LinkTokenInterface(link);
        s_competitionCount = 1;
    }

    /*//////////////////////////////////////////////////////////////
                                EXTERNAL
    //////////////////////////////////////////////////////////////*/
    /// @param theme of the competition
    /// @param submissionDeadline posts can be submitted to the competition until this deadline
    /// @param votingDeadline voting takes place between the submission deadline and this deadline
    /// @return competitionId unique identifier for competition
    function createCompetition(string memory theme, uint256 submissionDeadline, uint256 votingDeadline)
        external
        payable
        returns (uint256 competitionId)
    {
        // @review - what happens if someone sends a very small amount like 1 wei?
        // should we set a minimum prize pool to cover protocolFee?
        if (msg.value == 0) revert ContentCompetition__PrizePoolRequired();
        if (submissionDeadline <= block.timestamp) revert ContentCompetition__InvalidSubmissionDeadline();
        if (votingDeadline <= submissionDeadline) revert ContentCompetition__InvalidVotingDeadline();
        if (bytes(theme).length == 0) revert ContentCompetition__InvalidTheme();

        /// @dev get competitionId and update competitionCount storage
        competitionId = s_competitionCount;
        s_competitionCount = competitionId + 1;

        /// @dev separate protocolFee and prizePool, update storage
        uint256 protocolFee = _calculateProtocolFee(msg.value);
        uint256 prizePool = msg.value - protocolFee;
        if (protocolFee != 0) s_protocolFees += protocolFee;

        /// @dev update storage with competition details
        Competition storage comp = s_competitions[competitionId];
        comp.theme = theme;
        comp.submissionDeadline = submissionDeadline;
        comp.votingDeadline = votingDeadline;
        comp.prizePool = prizePool;

        // send ccipMessage with competitionId and votingDeadline to a chain with automation
    }

    function submitPost(uint256 competitionId, uint256 postId) external {
        Competition storage comp = s_competitions[competitionId];
        if (block.timestamp > comp.submissionDeadline) revert ContentCompetition__SubmissionsClosed();
    }

    function vote(uint256 competitionId, uint256 postId) external {}

    // NOTE: CHAINLINK AUTOMATION IS NOT ON LENS
    // WE NEED TO SEND A MESSAGE VIA CCIP TO A CHAIN WITH AUTOMATION

    // chainlink automation checkUpkeep checks competition deadline and prize distributed
    // chainlink automation loops through all competitions and as soon as there is one without
    // a prizeDistributed false and votingDeadline passed, the post author is sent the (prizePool - protocol fee)
    // protocolFee should be around 0.001%

    // performUpkeep distributes prize
    // function performUpkeep(bytes calldata performData) external onlyForwarder {
    //     if (msg.sender != s_forwarder) revert ContentCompetition__OnlyForwarder();
    //     (address author, uint256 prizePool) = abi.decode(performData, (address, uint256));

    //     // if (prizePool != 0)  // send to author
    // }
    // invariant: address(this).balance >= protocolFees + totalActivePrizePools

    function withdrawProtocolFees() external onlyOwner {}

    /*//////////////////////////////////////////////////////////////
                            INTERNAL
    //////////////////////////////////////////////////////////////*/
    /// @param message Any2EVMMessage.
    function _ccipReceive(Client.Any2EVMMessage memory message) internal override {}

    function _calculateProtocolFee(uint256 prizePool) internal returns (uint256 protocolFee) {
        // @review - could this cause under/overflow issues?
        return prizePool / FEE_DENOMINATOR;
    }
}
